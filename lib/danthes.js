// Generated by CoffeeScript 1.6.2
(function() {
  var Danthes, Faye, config, crypto,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Faye = require('faye');

  config = require('config').Danthes;

  crypto = require('crypto');

  module.exports = Danthes = (function() {
    var _this = this;

    function Danthes() {}

    Danthes.debug = false;

    Danthes.debugMessage = function(message) {
      if (this.debug) {
        return console.log(message);
      }
    };

    Danthes.reset = function() {
      this.connecting = false;
      this.fayeClient = null;
      this.fayeCallbacks = [];
      this.subscriptions = {};
      this.server = "" + config.server + config.mount;
      this.disables = [];
      return this.connectionSettings = {
        timeout: 120,
        retry: 5,
        endpoints: {}
      };
    };

    Danthes.faye = function(callback) {
      if (Danthes.fayeClient != null) {
        return callback(Danthes.fayeClient);
      } else {
        Danthes.fayeCallbacks.push(callback);
        if (Danthes.server) {
          Danthes.debugMessage('faye already inited');
          return Danthes.connectToFaye();
        }
      }
    };

    Danthes.fayeExtension = {
      incoming: function(message, callback) {
        Danthes.debugMessage("incomming message " + (JSON.stringify(message)));
        return callback(message);
      },
      outgoing: function(message, callback) {
        var subscription;

        Danthes.debugMessage("outgoing message " + (JSON.stringify(message)));
        if (message.channel === "/meta/subscribe") {
          subscription = Danthes.subscriptions[message.subscription]['opts'];
          if (message.ext == null) {
            message.ext = {};
          }
          message.ext.danthes_signature = subscription.signature;
          message.ext.danthes_timestamp = subscription.timestamp;
        } else {
          message.ext = {
            danthes_token: config.secret_token
          };
        }
        return callback(message);
      }
    };

    Danthes.connectToFaye = function() {
      var callback, key, _i, _j, _len, _len1, _ref, _ref1, _results;

      if (this.server && (Faye != null)) {
        this.debugMessage('trying to connect faye');
        this.fayeClient = new Faye.Client(this.server, this.connectionSettings);
        this.fayeClient.addExtension(this.fayeExtension);
        _ref = this.disables;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          this.fayeClient.disable(key);
        }
        this.debugMessage('faye connected');
        _ref1 = this.fayeCallbacks;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          callback = _ref1[_j];
          _results.push(callback(this.fayeClient));
        }
        return _results;
      }
    };

    Danthes.sign = function(options) {
      var channel;

      this.debugMessage('sign to faye');
      if (!this.server) {
        this.server = options.server;
      }
      channel = options.channel;
      if (this.subscriptions[channel] == null) {
        this.subscriptions[channel] = {};
        if (options['callback'] != null) {
          this.subscriptions[channel]['callback'] = options['callback'];
        }
        this.subscriptions[channel]['opts'] = this.generateSignature(channel);
        if ((options['connect'] != null) || (options['error'] != null)) {
          return this.activateChannel(channel, options);
        }
      }
    };

    Danthes.activateChannel = function(channel, options) {
      var _this = this;

      if (options == null) {
        options = {};
      }
      if (this.subscriptions[channel]['activated']) {
        return true;
      }
      return this.faye(function(faye) {
        var subscription;

        subscription = faye.subscribe(channel, function(message) {
          return _this.handleResponse(message);
        });
        if (subscription != null) {
          _this.subscriptions[channel]['sub'] = subscription;
          subscription.callback(function() {
            if (typeof options['connect'] === "function") {
              options['connect'](subscription);
            }
            return _this.debugMessage("subscription for " + channel + " is active now");
          });
          subscription.errback(function(error) {
            if (typeof options['error'] === "function") {
              options['error'](subscription, error);
            }
            return _this.debugMessage("error for " + channel + ": " + error.message);
          });
          return _this.subscriptions[channel]['activated'] = true;
        }
      });
    };

    Danthes.generateSignature = function(channel) {
      var signature, timestamp;

      timestamp = Math.round((new Date()).getTime() / 1000);
      signature = crypto.createHash('sha1').update(config.secret_token + channel + timestamp, 'utf8').digest('hex');
      return {
        timestamp: timestamp,
        signature: signature
      };
    };

    Danthes.handleResponse = function(message) {
      var callback, channel;

      channel = message.channel;
      if (this.subscriptions[channel] == null) {
        return;
      }
      if (callback = this.subscriptions[channel]['callback']) {
        return callback(message.data, channel);
      }
    };

    Danthes.disableTransport = function(transport) {
      if (transport !== 'websocket' && transport !== 'long-polling' && transport !== 'callback-polling' && transport !== 'in-process') {
        return;
      }
      if (__indexOf.call(this.disables, transport) < 0) {
        this.disables.push(transport);
        this.debugMessage("" + transport + " faye transport will be disabled");
      }
      return true;
    };

    Danthes.publishTo = function(channel, data) {
      return this.faye(function(faye) {
        return faye.publish(channel, {
          channel: channel,
          data: data
        });
      });
    };

    Danthes.subscribe = function(channel, callback, options) {
      if (options == null) {
        options = {};
      }
      this.debugMessage("subscribing to " + channel);
      if (this.subscriptions[channel] != null) {
        this.activateChannel(channel, options);
        this.subscriptions[channel]['callback'] = callback;
      } else {
        this.debugMessage("Cannot subscribe on channel '" + channel + "'. You need sign to channel first.");
        return false;
      }
      return true;
    };

    Danthes.unsubscribe = function(channel, fullUnsubscribe) {
      if (fullUnsubscribe == null) {
        fullUnsubscribe = false;
      }
      this.debugMessage("unsubscribing from " + channel);
      if (this.subscriptions[channel] && this.subscriptions[channel]['activated']) {
        this.subscriptions[channel]['sub'].cancel();
        if (fullUnsubscribe) {
          return delete this.subscriptions[channel];
        } else {
          delete this.subscriptions[channel]['activated'];
          return delete this.subscriptions[channel]['sub'];
        }
      }
    };

    Danthes.unsubscribeAll = function() {
      var channel, _, _ref, _results;

      _ref = this.subscriptions;
      _results = [];
      for (channel in _ref) {
        _ = _ref[channel];
        _results.push(this.unsubscribe(channel));
      }
      return _results;
    };

    return Danthes;

  }).call(this);

  Danthes.reset();

}).call(this);
